//-----------------------------LICENSE NOTICE------------------------------------
//  This file is part of CPCtelera: An Amstrad CPC Game Engine
//  Copyright (C) 2017 ronaldo / Fremos / Cheesetea / ByteRealms (@FranGallegoBR)
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU Lesser General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//-------------------------------------------------------------------------------

////////////////////////////////////////////////////////////////////////
// Group: General Useful Macros
////////////////////////////////////////////////////////////////////////

//
// Macro: cpctm_produceHalts
//
//   Produce a set of consecutive halt instructions in order to wait for 
// a given number of interrupts.
//
// C Definition:
//   #define <cpctm_produceHalts> (*N*)
//
// Input Parameters:
//   (_) N - Number of consecutive halts to be produced
//
// Known issues:
//    * *N* must be a constant expression that can evaluate to a number
// at compile time.
//    * If the code generated by this macro is executed with interrupts
// being disabled, your CPU will effectively hang forever.
//
// Size of generated code:
//    * *N* bytes (1 byte each halt instruction produced)
//
// Time Measures:
//    * Time depends on the exact moment of execution and the status of
// interrupts. *N* interrupts will pass.
//
// Details:
//    This macro produces a set of *N* consecutive *halt* assembly 
// instructions. Each *halt* instruction stops de Z80 CPU until 
// an interrupt is received. Therefore, this waits for *N* interrupts
// to be produced. This can be used for waiting or synchronization 
// purposes.
//
//    Please, take into account that this is a macro, and not a function.
// Each time this macro is used in your code it will produce the requested
// amount of halts. That can produce more code than you effectively need.
// For a unique function that controls a loop of *halt* waiting use
// <cpct_waitHalts> instead.
//
//
#define cpctm_produceHalts(N) \
   __asm \
      .rept N \
         halt \
      .endm \
   __endasm;
